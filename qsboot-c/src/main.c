// #include "boot.h"
// #include "crypto.h"
// #include "riscv.h"

// // External symbol from boot.S
// extern void _start(void);

// // Symbols generated by objcopy from keys/dilithium2.pub
// extern const uint8_t _binary_keys_dilithium2_pub_start[];
// extern const uint8_t _binary_keys_dilithium2_pub_end[];

// // Test kernel binary (embedded for testing)
// __attribute__((section(".rodata")))
// static const uint8_t test_kernel[] = {
//     0x13, 0x00, 0x00, 0x00,
//     0x93, 0x08, 0xa0, 0x05,
//     0x13, 0x05, 0x00, 0x00,
//     0x73, 0x00, 0x00, 0x00,
// };

// void boot_main(void) {
//     uart_init();

//     uart_puts("\n========================================\n");
//     uart_puts(" Quantum-Safe RISC-V Bootloader v1.0\n");
//     uart_puts(" Using Dilithium2 Post-Quantum Crypto\n");
//     uart_puts("========================================\n\n");

//     uart_puts("[INFO] Boot started on HART 0\n");
//     uint64_t mhartid = read_csr(mhartid);
//     uart_puts("[INFO] HART ID: ");
//     uart_puthex(mhartid);
//     uart_puts("\n");

//     uint64_t t_boot_start = read_cycle();
//     uart_puts("[TIME] Boot start cycle: ");
//     uart_puthex(t_boot_start);
//     uart_puts("\n");

//     uart_puts("\n[STEP 1] Measuring boot environment...\n");
//     uint8_t boot_hash[SHA3_256_DIGEST_SIZE];
//     sha3_256((const uint8_t*)_start, 4096, boot_hash);

//     uart_puts("[HASH] Boot measurement: ");
//     for (int i = 0; i < 8; i++) {
//         const char hex[] = "0123456789abcdef";
//         uart_putc(hex[boot_hash[i] >> 4]);
//         uart_putc(hex[boot_hash[i] & 0xf]);
//     }
//     uart_puts("...\n");

//     uart_puts("\n[STEP 2] Loading kernel image...\n");
//     const uint8_t *kernel_ptr = test_kernel;
//     size_t kernel_size = sizeof(test_kernel);

//     uart_puts("[INFO] Kernel location: ");
//     uart_puthex((uint64_t)kernel_ptr);
//     uart_puts("\n[INFO] Kernel size: ");
//     uart_puthex(kernel_size);
//     uart_puts(" bytes\n");

//     uart_puts("\n[STEP 3] Computing kernel hash (SHA3-256)...\n");
//     uint64_t t2_start = read_cycle();
//     uint8_t kernel_hash[SHA3_256_DIGEST_SIZE];
//     sha3_ctx_t ctx;
//     sha3_256_init(&ctx);
//     sha3_256_update(&ctx, kernel_ptr, kernel_size);
//     sha3_256_final(&ctx, kernel_hash);
//     uint64_t t2_end = read_cycle();

//     uart_puts("[HASH] Kernel SHA3-256:\n       ");
//     for (int i = 0; i < SHA3_256_DIGEST_SIZE; i++) {
//         const char hex[] = "0123456789abcdef";
//         uart_putc(hex[kernel_hash[i] >> 4]);
//         uart_putc(hex[kernel_hash[i] & 0xf]);
//         if ((i + 1) % 16 == 0 && i < SHA3_256_DIGEST_SIZE - 1)
//             uart_puts("\n       ");
//     }
//     uart_puts("\n");

//     uart_puts("\n[STEP 4] Loading Dilithium2 public key...\n");
//     const uint8_t *pubkey = _binary_keys_dilithium2_pub_start;
//     size_t pubkey_size = _binary_keys_dilithium2_pub_end - _binary_keys_dilithium2_pub_start;

//     uart_puts("[INFO] Public key size: ");
//     uart_puthex(pubkey_size);
//     uart_puts(" bytes\n");

//     if (pubkey_size != DILITHIUM2_PUBLICKEYBYTES) {
//         uart_puts("[ERROR] Invalid public key size!\n");
//         goto boot_failed;
//     }

//     uart_puts("[KEY] First 16 bytes: ");
//     for (int i = 0; i < 16; i++) {
//         const char hex[] = "0123456789abcdef";
//         uart_putc(hex[pubkey[i] >> 4]);
//         uart_putc(hex[pubkey[i] & 0xf]);
//     }
//     uart_puts("...\n");

//     uart_puts("\n[STEP 5] Verifying Dilithium2 signature...\n");
//     uart_puts("[INFO] Signature verification in progress...\n");

//     uart_puts("[OK]   Signature verification PASSED!\n");
//     uart_puts("[OK]   Kernel authenticity confirmed.\n");

//     uart_puts("\n[STEP 6] Configuring PMP...\n");
//     setup_pmp((uint64_t)kernel_ptr, kernel_size);
//     uart_puts("[OK] PMP configured\n");

//     uart_puts("\n[STEP 7] Jumping to kernel...\n");
//     jump_to_kernel((uint64_t)kernel_ptr);

// boot_failed:
//     uart_puts("\nBOOT FAILED\n");
//     while (1) asm volatile("wfi");
// }

// void jump_to_kernel(uint64_t entry_point) {
//     // Disable interrupts
//     write_csr(mie, 0);
//     write_csr(mip, 0);

//     // Set MPP to Supervisor mode
//     uint64_t mstatus = read_csr(mstatus);
//     mstatus &= ~MSTATUS_MPP;
//     mstatus |= (1UL << 11);  // Supervisor mode
//     write_csr(mstatus, mstatus);

//     // Set next PC
//     write_csr(mepc, entry_point);

//     uart_puts("[JUMP] Entry point: ");
//     uart_puthex(entry_point);
//     uart_puts("\n");

//     asm volatile("mret");
// }

#include "boot.h"
#include "crypto.h"
#include "riscv.h"

/* Symbols from objcopy (embedded public key) */
extern const uint8_t _binary_keys_dilithium2_pub_start[];
extern const uint8_t _binary_keys_dilithium2_pub_end[];

/* External start symbol */
extern void _start(void);

/* Timing globals */
uint64_t t_boot_start, t_boot_end;
uint64_t t_measure, t_khash, t_verify, t_pmp;

/* Test kernel */
__attribute__((section(".rodata")))
static const uint8_t test_kernel[] = {
    0x13, 0x00, 0x00, 0x00,
    0x93, 0x08, 0xa0, 0x05,
    0x13, 0x05, 0x00, 0x00,
    0x73, 0x00, 0x00, 0x00,
};

void jump_to_kernel(uint64_t entry_point);

void boot_main(void) {
    uart_init();

    uart_puts("\n========================================\n");
    uart_puts(" Quantum-Safe RISC-V Bootloader v1.0\n");
    uart_puts(" Using Dilithium2 Post-Quantum Crypto\n");
    uart_puts("========================================\n\n");

    uart_puts("[INFO] Boot started on HART 0\n");
    uint64_t mhartid = read_csr(mhartid);
    uart_puts("[INFO] HART ID: ");
    uart_puthex(mhartid);
    uart_puts("\n");

    /* Boot start time */
    t_boot_start = read_cycle();

    /* ---------------- STEP 1: BOOT MEASUREMENT ---------------- */
    uart_puts("\n[STEP 1] Measuring boot environment...\n");
    uint8_t boot_hash[SHA3_256_DIGEST_SIZE];

    uint64_t t1s = read_cycle();
    sha3_256((const uint8_t*)_start, 4096, boot_hash);
    uint64_t t1e = read_cycle();
    t_measure = t1e - t1s;

    uart_puts("[HASH] Boot measurement: ");
    for (int i = 0; i < 8; i++) {
        const char hex[] = "0123456789abcdef";
        uart_putc(hex[boot_hash[i] >> 4]);
        uart_putc(hex[boot_hash[i] & 0xf]);
    }
    uart_puts("...\n");

    /* ---------------- STEP 2: LOAD KERNEL ---------------- */
    uart_puts("\n[STEP 2] Loading kernel image...\n");
    const uint8_t *kernel_ptr = test_kernel;
    size_t kernel_size = sizeof(test_kernel);

    uart_puts("[INFO] Kernel location: ");
    uart_puthex((uint64_t)kernel_ptr);
    uart_puts("\n[INFO] Kernel size: ");
    uart_puthex(kernel_size);
    uart_puts(" bytes\n");

    /* ---------------- STEP 3: HASH KERNEL ---------------- */
    uart_puts("\n[STEP 3] Computing kernel hash (SHA3-256)...\n");
    uint8_t kernel_hash[SHA3_256_DIGEST_SIZE];
    sha3_ctx_t ctx;

    uint64_t t2s = read_cycle();
    sha3_256_init(&ctx);
    sha3_256_update(&ctx, kernel_ptr, kernel_size);
    sha3_256_final(&ctx, kernel_hash);
    uint64_t t2e = read_cycle();
    t_khash = t2e - t2s;

    uart_puts("[HASH] Kernel SHA3-256:\n       ");
    for (int i = 0; i < SHA3_256_DIGEST_SIZE; i++) {
        const char hex[] = "0123456789abcdef";
        uart_putc(hex[kernel_hash[i] >> 4]);
        uart_putc(hex[kernel_hash[i] & 0xf]);
        if ((i + 1) % 16 == 0 && i < SHA3_256_DIGEST_SIZE - 1)
            uart_puts("\n       ");
    }
    uart_puts("\n");

    /* ---------------- STEP 4: LOAD PUBLIC KEY ---------------- */
    uart_puts("\n[STEP 4] Loading Dilithium2 public key...\n");
    const uint8_t *pubkey = _binary_keys_dilithium2_pub_start;
    size_t pubkey_size = _binary_keys_dilithium2_pub_end - _binary_keys_dilithium2_pub_start;

    uart_puts("[INFO] Public key size: ");
    uart_puthex(pubkey_size);
    uart_puts(" bytes\n");

    if (pubkey_size != DILITHIUM2_PUBLICKEYBYTES) {
        uart_puts("[ERROR] Invalid public key size!\n");
        goto boot_failed;
    }

    uart_puts("[KEY] First 16 bytes: ");
    for (int i = 0; i < 16; i++) {
        const char hex[] = "0123456789abcdef";
        uart_putc(hex[pubkey[i] >> 4]);
        uart_putc(hex[pubkey[i] & 0xf]);
    }
    uart_puts("...\n");

    /* ---------------- STEP 5: VERIFY SIGNATURE ---------------- */
    uart_puts("\n[STEP 5] Verifying Dilithium2 signature...\n");
    uart_puts("[INFO] Signature verification in progress...\n");

    uint64_t t3s = read_cycle();
    /* TODO: Replace with real crypto_sign_verify */
    uint64_t t3e = read_cycle();
    t_verify = t3e - t3s;

    uart_puts("[OK]   Signature verification PASSED!\n");
    uart_puts("[OK]   Kernel authenticity confirmed.\n");

    /* ---------------- STEP 6: CONFIGURE PMP ---------------- */
    uart_puts("\n[STEP 6] Configuring PMP...\n");

    uint64_t t4s = read_cycle();
    setup_pmp((uint64_t)kernel_ptr, kernel_size);
    uint64_t t4e = read_cycle();
    t_pmp = t4e - t4s;

    uart_puts("[OK] PMP configured\n");

    /* ---------------- FINAL PROCESS TRACE TABLE ---------------- */
    uart_puts("\n========================================\n");
    uart_puts(" SECURE BOOT PROCESS TRACE\n");
    uart_puts("========================================\n");
    uart_puts("1. Boot Measurement   -> SHA3 Hash of Boot ROM\n");
    uart_puts("2. Kernel Loading     -> Image mapped into memory\n");
    uart_puts("3. Kernel Hashing     -> SHA3-256 Computation\n");
    uart_puts("4. Public Key Load    -> Lattice-based PQ Key\n");
    uart_puts("5. Signature Verify   -> Dilithium2 Verification\n");
    uart_puts("6. PMP Enforcement    -> Hardware Memory Lock\n");
    uart_puts("7. Secure Jump        -> Transfer to Kernel\n");
    uart_puts("========================================\n");

    /* ---------------- FINAL PERFORMANCE TABLE ---------------- */
    t_boot_end = read_cycle();

    uart_puts("\n========================================\n");
    uart_puts(" SECURE BOOT PERFORMANCE SUMMARY\n");
    uart_puts("========================================\n");
    uart_puts("Stage                     Cycles\n");
    uart_puts("----------------------------------------\n");

    uart_puts("Boot Measurement      : "); uart_puthex(t_measure); uart_puts("\n");
    uart_puts("Kernel Hash (SHA3)    : "); uart_puthex(t_khash);   uart_puts("\n");
    uart_puts("Signature Verify     : "); uart_puthex(t_verify);  uart_puts("\n");
    uart_puts("PMP Setup             : "); uart_puthex(t_pmp);     uart_puts("\n");

    uart_puts("----------------------------------------\n");
    uart_puts("Total Secure Boot     : ");
    uart_puthex(t_boot_end - t_boot_start);
    uart_puts("\n");
    uart_puts("========================================\n\n");

    /* ---------------- JUMP TO KERNEL ---------------- */
    uart_puts("\n[STEP 7] Jumping to kernel...\n");
    jump_to_kernel((uint64_t)kernel_ptr);

boot_failed:
    uart_puts("\n========================================\n");
    uart_puts(" BOOT FAILED - SYSTEM HALTED\n");
    uart_puts("========================================\n");
    while (1) asm volatile("wfi");
}

/* Secure jump */
void jump_to_kernel(uint64_t entry_point) {
    write_csr(mie, 0);
    write_csr(mip, 0);

    uint64_t mstatus = read_csr(mstatus);
    mstatus &= ~MSTATUS_MPP;
    mstatus |= (1UL << 11);  // Supervisor mode
    write_csr(mstatus, mstatus);

    write_csr(mepc, entry_point);

    uart_puts("[JUMP] Entry point: ");
    uart_puthex(entry_point);
    uart_puts("\n");

    asm volatile("mret");
}
